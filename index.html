<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script>
      MathJax = {
        tex: {
          inlineMath: [['\\(', '\\)']]
        },
        svg: {
          fontCache: 'global'
        }
      };
    </script>
    <script type="text/javascript" id="MathJax-script" async src="mathjax/es5/tex-svg.js"></script>
    <script>
      function rebase(value, inbase, outbase) {
        let output = [];
        for(let remainder of value) {
          for(let digit = 0; digit < output.length; digit++) {
            remainder = inbase * output[digit] + remainder;
            output[digit] = remainder % outbase;
            remainder = Math.floor(remainder / outbase);
          }
          while(remainder) {
            output.push(remainder % outbase);
            remainder = Math.floor(remainder / outbase);
          }
        }
        return output.reverse();
      }

      function translate(value, inalphabet, outalphabet) {
        let rebased = rebase(value.split("").map(x => inalphabet.indexOf(x)),
          inalphabet.length, outalphabet.length);
        return rebased.map(x => outalphabet[x]).join("");
      }

      const b3enc = x => translate(x.toString(), "0123456789", "012")
      const b3dec = x => parseInt(translate(x, "012", "0123456789"))

      function b3ltr(x) {
        let carry = 0;
        return x.split("").map(y => {
          let res = carry ? y === "0" ? "1" : "2" : y === "2" ? "1" : "0"
          carry ^= y === "1"
          return res
        }).join("") + (carry === 0 ? "" : "2")
      }

      function b3seq(x) {
        console.assert(x !== "")
        let seq = [x], b10 = [b3dec(x)], pre = [0, 0], cur = 0
        while (x !== "1") {
          const y = b3ltr(x)
          seq.push(y)
          b10.push(b3dec(y))
          x = y.replace(/^0*/, "")
          pre.push(cur += y.length - x.length)
        }
        return [seq, b10, pre]
      }

      window.addEventListener("DOMContentLoaded", () => {
        document.querySelectorAll("a").forEach(el => {
          if (el.childNodes.length === 1 && el.firstElementChild === null)
            el.innerText = el.innerText.trim()
        })

        const e0b10 = document.getElementById("ex0base10")
        const e0b03 = document.getElementById("ex0base03")
        const ex0el = document.getElementById("ex0")
        const selall = e => { e.target.select() }
        const ex0pad = 8
        const ex0 = x => {
          const [seq, b10, pre] = b3seq(x)
          const s10 = b10.map(x => x.toString())
          const lines = seq.map((x, i) => " ".repeat(pre[i]) + x)
          const align = ex0pad + lines.slice(-1)[0].length + Math.max(
            ...s10.map(x => x.length))
          const res = lines.map((x, i) =>
            x + " ".repeat(align - x.length - s10[i].length) + s10[i])
          ex0el.innerText = res.join("\n")
        }

        e0b10.addEventListener("focus", selall, { "passive": true })
        e0b03.addEventListener("focus", selall, { "passive": true })
        e0b10.addEventListener("input", e => {
          const x = b3enc(e0b10.value || e0b10.placeholder)
          e0b03.value = e0b10.value && x
          ex0(x)
        }, { "passive": true })
        e0b03.addEventListener("input", e => {
          const x = e0b03.value || e0b03.placeholder
          e0b10.value = e0b03.value && b3dec(x)
          ex0(x)
        }, { "passive": true })
        if (e0b10.value && e0b10.value !== e0b10.placeholder) ex0(e0b03.value)
      })
    </script>
  </head>
  <body>
    <div class="content">
      <div class="conjecture">
        For the sequence
        \begin{align}
          a_0&\in\mathbb{N} \\
          a_{k+1}&= \left\{
            \begin{array}{rl}
              a_k \div 2 & \quad2\mid a_k \\
              3a_k+1 & \quad2\nmid a_k
            \end{array}
          \right.
        \end{align}
        the Collatz conjecture states that
        \begin{equation}
          \forall\,a_0\,\exists\,k\text{ such that } a_k=1
        \end{equation}
      </div>
      <hr>
      In base 2, the process can be rephrased as repeatedly
      <ol>
        <li>Appending 1 to the end of the number</li>
        <li>Adding the result to the previous number</li>
        <li>Removing trailing 0s</li>
      </ol>
      For example (via
      <a href="https://en.wikipedia.org/w/index.php?title=Collatz_conjecture&oldid=1298684967#Example">
        Wikipedia
      </a>), \(7=111_2\)
<pre>
         111         7
        <u>111<b>1</b></u>
       1011<s>0</s>        11
      <u>1011<b>1</b></u>
     10001<s>0</s>         17
    <u>10001<b>1</b></u>
    1101<s>00</s>          13
   <u>1101<b>1</b></u>
  101<s>000</s>             5
 <u>101<b>1</b></u>
1<s>0000</s>                1
</pre>
      The process can be rephrased in base 3 with a 1 (carry) bit left-to-right
      state-machine.
      <ul>
        <li>Initially, the carry bit is off, so \(0\to0\) and \(2\to1\)</li>
        <li>With the carry bit off, \(1\to0\), flipping the carry bit on</li>
        <li>With the carry bit on, \(1\to2\), flipping the carry bit off</li>
        <li>With the carry bit on, \(0\to1\) and \(2\to2\)</li>
        <li>If the number ends with the carry bit on, append 2</li>
      </ul>
      Using
      <input type="number" value="7"  placeholder="7"  size="2" id="ex0base10">
      </input>
      =
      <input type="number" value="21" placeholder="21" size="4" id="ex0base03">
      </input>
      <sub>3</sub>
<pre id="ex0">
21              7
102            11
0122           17
 0222          26
  111          13
  0202         20
   101         10
   012          5
    022         8
     11         4
     02         2
      1         1
</pre>
      If the carry bit is off for the last digit, the two ways to end up with 0
      are
      <ol>
        <li>the digit is already 0</li>
        <li>
          the digit is a 1, in which case the number will end with the carry bit
          on and a 2 will be appended, meaning the new number will not end in 0
        </li>
      </ol>
      If the carry bit is on for the last digit, there is no way to end up with
      a zero. This means that once a number \(\not\equiv 0\ (\text{mod}\ 3)\)
      it will stay that way. We can upper bound the number of steps that end in
      0 since it requires that the right side stays fixed, meaning the number is
      only being divided by 2. Going forwards, numbers ending in 0 can be
      ignored by this version of the process.
    </div>
    <style>
      .content {
        max-width: 40em;
        margin-left: auto;
        margin-right: auto;
      }

      .conjecture {
        text-align: center;
      }

      input[type=number] {
        font-family: inherit;
        border-color: #aaa;
        border-width: 0 0 0.2em 0;
        outline: 0;
        text-align: right;
        font-size: inherit;
      }

      input[type=number]:focus {
        border-color: #007aff;
      }

      /* https://stackoverflow.com/a/4298216/3476782 */
      input::-webkit-outer-spin-button, input::-webkit-inner-spin-button {
        -webkit-appearance: none;
        margin: 0;
      }

      input[type=number] {
        -moz-appearance: textfield;
      }
    </style>
  </body>
</html>
