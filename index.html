<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script>
      MathJax = {
        tex: {
          inlineMath: [['\\(', '\\)']]
        },
        svg: {
          fontCache: 'global'
        }
      };
    </script>
    <script type="text/javascript" id="MathJax-script" async src="mathjax/es5/tex-svg.js"></script>
    <script>
      window.addEventListener("DOMContentLoaded", () => {
        document.querySelectorAll("a").forEach(el => {
          if (el.childNodes.length === 1 && el.firstElementChild === null)
            el.innerText = el.innerText.trim()
        })
      })
    </script>
  </head>
  <body>
    <div class="content">
      <div class="conjecture">
        For the sequence
        \begin{align}
          a_0&\in\mathbb{N} \\
          a_{k+1}&= \left\{
            \begin{array}{rl}
              a_k \div 2 & \quad2\mid a_k \\
              3a_k+1 & \quad2\nmid a_k
            \end{array}
          \right.
        \end{align}
        the Collatz conjecture states that
        \begin{equation}
          \forall\,a_0\,\exists\,k\text{ such that } a_k=1
        \end{equation}
      </div>
      <hr>
      In base 2, the process can be rephrased as repeatedly
      <ol>
        <li>Appending 1 to the end of the number</li>
        <li>Adding the result to the previous number</li>
        <li>Removing trailing 0s</li>
      </ol>
      For example (via
      <a href="https://en.wikipedia.org/w/index.php?title=Collatz_conjecture&oldid=1298684967#Example">
        Wikipedia
      </a>), \(7=111_2\)
<pre>
         111         7
        <u>111<b>1</b></u>
       1011<s>0</s>        11
      <u>1011<b>1</b></u>
     10001<s>0</s>         17
    <u>10001<b>1</b></u>
    1101<s>00</s>          13
   <u>1101<b>1</b></u>
  101<s>000</s>             5
 <u>101<b>1</b></u>
1<s>0000</s>                1
</pre>
      The process can be rephrased in base 3 with a 1 (carry) bit left-to-right
      state-machine.
      <ul>
        <li>Initially, the carry bit is off, so \(0\to0\) and \(2\to1\)</li>
        <li>With the carry bit off, \(1\to0\), flipping the carry bit on</li>
        <li>With the carry bit on, \(1\to2\), flipping the carry bit off</li>
        <li>With the carry bit on, \(0\to1\) and \(2\to2\)</li>
        <li>If the number ends with the carry bit on, append 2</li>
      </ul>
      using \(7=21_3\)
<pre>
21              7
102            11
0122           17
 0222          26
  111          13
  0202         20
   101         10
   012          5
    022         8
     11         4
     02         2
      1         1
</pre>
      If the carry bit is off for the last digit, the two ways to end up with 0
      are
      <ol>
        <li>the digit is already 0</li>
        <li>
          the digit is a 1, in which case the number will end with the carry bit
          on and a 2 will be appended, meaning the new number will not end in 0
        </li>
      </ol>
      If the carry bit is on for the last digit, there is no way to end up with
      a zero. This means that once a number \(\not\equiv 0\ (\text{mod}\ 3)\)
      it will stay that way. We can upper bound the number of steps that end in
      0 since it requires that the right side stays fixed, meaning the number is
      only being divided by 2. Going forwards, numbers ending in 0 can be
      ignored by this version of the process.
    </div>
    <style>
      .content {
        max-width: 40em;
        margin-left: auto;
        margin-right: auto;
      }

      .conjecture {
        text-align: center;
      }
    </style>
  </body>
</html>
